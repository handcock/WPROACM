
library(WPROACM)
library(RColorBrewer)
library(lattice)
library(latticeExtra)

data(ExampleCountries, package="WPROACM")

BRGcol <- "darkred"
CUGcol <- "darkorange"
obsblue <- "#076EC3"
histblue <- "#83B6E1"
tgray3 <- adjustcolor("gray", alpha.f = 0.3)
tgray7 <- adjustcolor("gray", alpha.f = 0.7)

shinyServer(
  function(input, output, session){

    oldoptions <- options()
    on.exit(options(oldoptions))
    options(digits=3)


# Reactive Expressions ----------------------------------------------------
# These expressions contain most of the code from the ergm package that we will
# be using. Objects created with a reactive expression can be accessed from any
# other reactive expression or render functions and they only get re-run when
# their values are outdated. Since many of our render functions will be calling
# the same ergm objects, using reactive expressions will help the app run much
# faster.


values <- reactiveValues()

# when two options are available to the user, or when we need to know if one
# variable is outdated this reactive value will keep track of the state
state <- reactiveValues(symmdir = FALSE, plotperc_dd = FALSE,
                        plotperc_gd = FALSE, gof = 0)

#move to Help page when user clicks Help link button
observe({
  if(input$helpLink == 0) {return()}
  isolate({
    updateTabsetPanel(session, 'navbar', selected='tab6')
  })
})

#move to Data panel when user clicks Get Started button
observe({
  if(input$startButton == 0) {return()}
  isolate({
    updateTabsetPanel(session, 'navbar', selected='tab2')
  })
})

#update active tab in navbar when arrows are clicked
leftarrowclicks <- reactive({
  input$dataleft+input$plotleft
})
rightarrowclicks <- reactive({
  input$dataright+input$plotright
})
observe({
  if(leftarrowclicks() == 0) {return()}
  tabOptions <- c('tab1', 'tab2', 'tab3', 'tab4', 'tab5', 'tab6')
  current <- isolate(which(input$navbar==tabOptions))
  updateTabsetPanel(session, 'navbar', selected=tabOptions[current-1])
})
observe({
  if(rightarrowclicks() == 0) {return()}
  tabOptions <- c('tab1', 'tab2', 'tab3', 'tab4', 'tab5', 'tab6')
  current <- isolate(which(input$navbar==tabOptions))
  updateTabsetPanel(session, 'navbar', selected=tabOptions[current+1])
})


## Data Selection ------------------------------------------------------

#nwinit is used to get the initial values of the network
nwinit <- reactive({
  #input$rawdatafile comes as a dataframe with name, size, type and datapath
  #datapath is stored in 4th column of dataframe
  #network creates a network object from the input file
  if(is.null(input$rawdatafile)){
    nw_var <- NULL
  } else {
    filepath <- input$rawdatafile[1,4]
    filename <- input$rawdatafile[1,1]
    fileext <- substr(filename,nchar(filename)-3,nchar(filename))

    if(input$filetype == 1){
      validate(
        need(fileext %in% c(".csv", ".CSV"),
             "Upload an .csv file"))
        header <- TRUE
        row_names<-1
        try({nw_var <- read.csv(paste(filepath), sep=",", header=header)
             })
# save(nw_var, file = paste0("~/",filename,".RData"))
    }
  }
  if(input$filetype == 2){
    if(input$samplenet == ""){
      nw_var <- NULL
    } else {
      net_name <- c('Australia','Japan','South_Korea', 'New_Zealand', 'Philippines')[
        match(input$samplenet,c('Australia','Japan',
                                'South Korea', 'New Zealand', 'Philippines'))]
      nw_var <- eval(parse(text = net_name))
    }
  }
  return(nw_var)
})

iso3 <- reactive({
  iso3 <- NULL
  if(input$filetype == 2){
    if(input$samplenet != ""){
      iso3 <- c('AUD','JPN','KOR', 'NZL', 'PHL')[
        match(input$samplenet,c('Australia','Japan',
                                'South Korea', 'New Zealand', 'Philippines'))]
    }
  }
  return(iso3)
})

nwname <- reactive({
  name <- input$rawdatafile[1,1]
  if(input$filetype == 2){
    name <- input$samplenet
  }
  name
})

#compute the spline model  for the expected deaths
output_spline <- reactive({
  if(!is.data.frame(nwinit())){return()}
  calculate_spline(nwinit())
})

## Network Descriptives (Plots) ------------------------------------------------------

# Output Expressions -------------------------------------------------------

# Every piece of content that gets displayed in the app has to be
# rendered by the appropriate `render*` function, e.g. `renderPrint` for text
# and `renderPlot` for plots. Most of the render functions here call
# reactive objects that were created above. I have divided the output objects
# into sections depending on what tab of the app they are called from.


## Data Upload -------------------------------------------------------------



output$datadesc <- renderUI({
  net <- input$samplenet
  text <- div()
  # if(net == "ecoli1" | net == "ecoli2"){
  #   text <- div(
  #     p("The", code("ecoli", class = "codetxt"),
  #       "network data set comprises two versions of a",
  #       "biological network in which the nodes are operons in",
  #       em("Escherichia Coli"), "and a directed edge from one node to another",
  #       "indicates that the first encodes the transcription factor that",
  #       "regulates the second."),
  #     p("The network object", code("ecoli1", class = "codetxt"),
  #       "is directed, with 423 nodes", "and 519 ties. The object",
  #       code("ecoli2", class = "codetxt"), "is an undirected",
  #       "version of the same network, in which the five isolated nodes",
  #       "(which exhibit only self-regulation in",
  #       code("ecoli1", class = "codetxt"), "are removed, leaving 418 nodes."),
  #     p("The data set is based on the RegulonDB network (Salgado et al, 2001)",
  #       "and was modified by Shen-Orr et al (2002)."),
  #     strong("References"),
  #     p("Salgado et al (2001), Regulondb (version 3.2): Transcriptional",
  #       "Regulation and Operon Organization in Escherichia Coli K-12,",
  #       em("Nucleic Acids Research,"), "29(1): 72-74."),
  #     p("Shen-Orr et al (2002), Network Motifs in the Transcriptional",
  #       "Regulation Network of Escerichia Coli,", em("Nature Genetics,"),
  #       "31(1): 64-68.")
  #   )
  # }
  if(net == "Australia"){
    text <- div(
      p("This is the data from Australia.")
    )
  }
  if(net == "Korea"){
    text <- div(
      p("The two", code("florentine", class = "codetxt"), "networks are of",
        "marriage and business ties among Renaissance",
        "Florentine families. The data is originally from Padgett (1994) via",
        "UCINET and stored as", code("statnet", class = "codetxt"),
        "network objects."),
      p("Breiger & Pattison (1986), in their discussion of local role analysis,",
        "use a subset of data on the social relations among Renaissance",
        "Florentine families (person aggregates) collected by John Padgett from",
        "historical documents.", code("flobusiness", class = "codetxt"),
        "contains business ties - specifically, recorded",
        "financial ties such as loans, credits and joint partnerships.",
        code("flomarriage", class = "codetxt"), "contains marriage alliances."),
      p("As Breiger & Pattison point out, the original data are symmetrically",
        "coded. This is acceptable perhaps for marital ties, but is unfortunate",
        "for the financial ties (which are almost certainly directed). Both",
        "graphs provide vertex information on (1) each family's net wealth in",
        "1427 (in thousands of lira); (2) the number of priorates (seats on the",
        "civic council) held between 1282- 1344; and (3) the total number of",
        "business or marriage ties in the total dataset of 116 families",
        "(see Breiger & Pattison (1986), p 239)."),
      p("Substantively, the data include families who were locked in a struggle",
        "for political control of the city of Florence around 1430. Two",
        "factions were dominant in this struggle: one revolved around the",
        "infamous Medicis (9), the other around the powerful Strozzis (15)."),
      strong("References"),
      p("Wasserman, S. and Faust, K. (1994)",
        em("Social Network Analysis: Methods and Applications,"),
        "Cambridge University Press, Cambridge, England."),
      p("Breiger, R. and Pattison, P. (1986).",
        em("Cumulated social roles: The duality of persons and their algebras,"),
        "Social Networks, 8, 215-256.")
      )
  }
  if(net == "kapferer" | net == "kapferer2"){
    text <- div(
      p('This well-known social network dataset, collected by Bruce Kapferer',
        'in Zambia from June 1965 to August 1965, involves interactions among',
        'workers in a tailor shop as observed by Kapferer himself. Here, an',
        'interaction is defined by Kapferer as "continuous uninterrupted social',
        'activity involving the participation of at least two persons"; only',
        'transactions that were relatively frequent are recorded. All of the',
        'interactions in this particular dataset are "sociational", as opposed',
        'to "instrumental". Kapferer explains the difference (p. 164) as follows:'),
      p('"I have classed as transactions which were sociational in content those',
        'where the activity was markedly convivial such as general conversation,',
        'the sharing of gossip and the enjoyment of a drink together. Examples',
        'of instrumental transactions are the lending or giving of money,',
        'assistance at times of personal crisis and help at work."'),
      p("Kapferer also observed and recorded instrumental transactions, many of",
        "which are unilateral (directed) rather than reciprocal (undirected),",
        "though those transactions are not recorded here. In addition, there was",
        "a second period of data collection, from September 1965 to January 1966,",
        "but these data are also not recorded here. All data are given in",
        "Kapferer's 1972 book on pp. 176-179."),
      p("During the first time period, there were 43 individuals working in this",
        "particular tailor shop; however, the better-known dataset includes only",
        "those 39 individuals who were present during both time collection",
        "periods. (Missing are the workers named Lenard, Peter, Lazarus, and",
        "Laurent.) Thus, we give two separate networks here:",
        code("kapferer", class = "codetxt"), "is the well-known 39-individual",
        "dataset, whereas", code("kapferer2", class = "codetxt"), "is the full",
        "43-individual dataset."),
      strong("References"),
      p("Kapferer, Bruce (1972), Strategy and Transaction in an African Factory,",
        "Manchester University Press.")
    )
  }
  if(net == "molecule") {
    text <- div(
      p(code("molecule", class = "codetxt"),
        "is a synthetic network of 20 nodes that is used as an example within",
        "the", code("ergm", class = "codetxt"),
        "documentation. It has an interesting elongated shape - reminencent of",
        "a chemical molecule."))
  }
  if(net == "samplike" | net == "samplk1" | net == "samplk2" | net == "samplk3"){
    text <- div(
      p('Sampson (1969) recorded the social interactions among a group of monks',
        'while resident as an experimenter on vision, and collected numerous',
        'sociometric rankings. During his stay, a political “crisis in the',
        'cloister" resulted in the expulsion of four monks (Nos. 2, 3, 17, and',
        '18) and the voluntary departure of several others - most immediately,',
        'Nos. 1, 7, 14, 15, and 16. (In the end, only 5, 6, 9, and 11 remained).',
        'Of particular interest is the data on positive affect relations',
        '(“liking"), in which each monk was asked if they had positive',
        'relations to each of the other monks.'),
      p('The data were gathered at three times to capture changes in group',
        'sentiment over time:', code("samplk1, samplk2", class = "codetxt"), "and",
        code("samplk3.", class = "codetxt"), 'They represent three time points',
        'in the period during which a new cohort entered the monastery near the',
        'end of the study but before the major conflict began. Each member',
        'ranked only his top three choices on “liking." (Some subjects offered',
        'tied ranks for their top four choices). A tie from monk A to monk B',
        'exists if A nominated B as one of his three best friends at that that',
        'time point.'),
      p(code("samplk3", class = "codetxt"),
        "is a data set of Hoff, Raftery and Handcock (2002)."),
      p(code('samplike', class = "codetxt"),
        'is the time-aggregated graph. It is the cumulative tie for “liking"',
        'over the three periods. For this, a tie from monk A to monk B exists',
        'if A nominated B as one of his three best friends at any of the three',
        'time points.'),
      p('The graphs have three vertex attributes: ',
        tags$ul(
          tags$li('Groups of novices as classified by Sampson: "Loyal",',
                  '"Outcasts", and "Turks". There is also an interstitial',
                  'group not represented here.'),
          tags$li('An indicator of attendance the minor seminary of',
                  '“Cloisterville" before coming to the monastery.'),
          tags$li('The given names of the novices.')
          )),
      strong("References"),
      p("Sampson, S.F. (1968), A novitiate in a period of change:",
        em("An experimental and case study of relationships,"),
        "Unpublished Ph.D. dissertation, Department of Sociology,",
        "Cornell University."),
      p("White, H.C., Boorman, S.A. and Breiger, R.L. (1976).",
        em("Social structure from multiple networks. I. Blockmodels of roles",
           "and positions."), "American Journal of Sociology, 81(4), 730-780."),
      p("Wouter de Nooy, Andrej Mrvar, Vladimir Batagelj (2005)",
        em("Exploratory Social Network Analysis with Pajek,"),
        "Cambridge: Cambridge University Press")

      )
  }

  text
})

#output$iristbl = DT::renderDT(
#      iris, options = list(lengthChange = FALSE)
#      )
#output$iris_table = DT::renderDataTable({
#      datatable(iris(),  extensions = 'Responsive')
#      })
output$ACM_table = shiny::renderDataTable(
      {nwinit()}
      )
output$spline_table = shiny::renderDataTable(
      {output_spline()}
      )
output$iris_table = shiny::renderDataTable(
      {iris}, options = list(pageLength = 10)
      )

output$rawdatafile <- renderPrint({
  raw <- matrix(nrow=2,ncol=1)
  rownames(raw)<-c("name:", "size:")
  if(!is.null(input$rawdatafile)){
    raw[1,1] <- input$rawdatafile[1,1]
    raw[2,1] <- paste(input$rawdatafile[1,2], " bytes")
  }
  write.table(raw, quote=FALSE, col.names=FALSE)})

#summary of network attributes
output$ACMsum <- renderPrint({
  if (is.null(nwinit())){
    return(cat('NA'))
  }
  nw_var <- nwinit()
  if (class(nw_var)!="data.frame"){
    return(str(nw_var))
  }
  return(str(nw_var))
})

## Network Descriptives ------------------------------------------------------

#NETWORK PLOT

#output$nwplotdownload <- downloadHandler(
#  filename = function(){paste(nwname(),'_plot.pdf',sep='')},
#  content = function(file){
#    pdf(file=file, height=10, width=10)
#    nw_var <- nw()
#    color <- adjustcolor(vcol(), alpha.f = input$transp)
#    plot.network(nw_var, coord = coords(),
#                 displayisolates = input$iso,
#                 displaylabels = input$vnames,
#                 vertex.col = color,
#                 vertex.cex = nodesize())
#    if(input$colorby != 2){
#      legend('bottomright', title=input$colorby, legend = legendlabels(),
#             fill = legendfill())
#    }
#    dev.off()
#  }
#  )

})
